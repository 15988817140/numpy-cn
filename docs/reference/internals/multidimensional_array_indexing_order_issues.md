# 多维数组索引顺序问题

索引多维数组的正确方法是什么？在对多维数组的索引方式和真正的方法做出结论之前，理解为什么这是一个令人困惑的问题是值得的。本节将试图详细解释numpy索引是如何工作的，以及为什么我们对图像采用这种约定，以及何时可以采用其他约定。

首先要理解的是，索引二维数组有两个相互冲突的约定。矩阵表示法使用第一个索引指示正在选择的行，使用第二个索引指示选择的列。这与面向几何的图像惯例相反，在图像中，人们通常认为第一个索引表示x位置(即列)，第二个索引表示y位置(即行)。这本身就是许多混乱的根源；面向矩阵的用户和面向图像的用户期望在索引方面有两种不同的东西。

需要理解的第二个问题是索引如何与数组存储在内存中的顺序相对应。在Fortran中，当在存储在内存中的二维数组的元素中移动时，第一个索引是变化最快的索引。如果采用矩阵约定进行索引，那么这意味着矩阵一次存储一列(因为第一个索引在更改时移动到下一行)。因此，fortran被认为是一种主要的专栏语言。c的约定正好相反。在C语言中，最后一个索引随着存储在内存中的数组的移动而变化得最快。因此，C是一种行主要语言。矩阵按行存储。请注意，在这两种情况下，它都假定正在使用用于索引的矩阵约定，即对于Fortran和C，第一个索引是行。注意：此约定意味着索引约定是不变的，并且数据顺序会更改以保持不变。

但这并不是看问题的唯一方式。假设有一个大型二维数组(图像或矩阵)存储在数据文件中.。假设数据是按行而不是按列存储的。如果我们要保留索引约定(无论是矩阵还是图像)，这意味着根据所使用的语言，如果数据被读入内存以保留索引约定，则可能会被迫重新排序。例如，如果我们在没有重新排序的情况下将行顺序数据读入内存，那么它将匹配C的矩阵索引约定，而不是fortran的矩阵索引约定。相反，它将匹配Fortran的图像索引约定，而不匹配C的图像索引约定。对于C，如果使用按行顺序存储的数据，并且希望保留图像索引约定，则在将数据读入内存时必须重新排序。

最后，您为Fortran或C所做的工作取决于哪个更重要，而不是重新排序数据或保留索引约定。对于大型图像，重新排序数据的代价可能很大，为了避免这种情况，索引惯例通常是倒置的。

Numpy的情况使这个问题更加复杂。Numpy数组的内部机制足够灵活，可以接受任何索引顺序。可以简单地通过操作数组的内部跨步信息来重新排序索引，而不需要重新排序数据。NumPy将知道如何在不移动数据的情况下将新的索引顺序映射到数据。

那么，如果这是真的，为什么不选择与您最期望的索引顺序相匹配的索引呢？特别是，为什么不定义行顺序的图像来使用图像约定呢？(这有时被称为Fortran约定与C约定，因此以numpy为单位的数组排序的‘C’和‘FORTRAN’顺序选项。)。这样做的缺点是潜在的性能惩罚。按顺序访问数据是常见的，可以在数组操作中隐式地访问，也可以通过遍历图像的行来显式地访问。这样做后，数据将以非最佳顺序访问。随着第一个索引的增加，实际上正在发生的是，在内存中间隔很远的元素正在按顺序访问，通常内存访问速度很差。例如，对于二维图像‘im’，定义为im[0, 10]表示x=0，y=10的值。为了与通常的Python行为保持一致，im[0]将表示x=0处的一列。但是，由于数据是按行顺序存储的，所以这些数据会分散到整个数组中。尽管numpy的索引具有灵活性，但它不能真正掩盖这样一个事实，即由于数据顺序或获取连续子数组仍然很笨拙(例如，第一行im[:, 0]vs im[0])，基本操作效率低下，因此不能使用类似于im中的行这样的成语；对于colin，im确实可以工作，但不会产生连续的列数据。

事实证明，numpy在处理ufuns时足够聪明，可以确定哪个索引是内存中变化最快的索引，并将其用于最内层的循环。因此，在大多数情况下，这两种方法都没有很大的内在优势。另一方面，在FORTRAN有序数组中使用.plan将导致非最佳内存访问，因为扁平数组(实际上是迭代器)中的相邻元素在内存中不是连续的。

事实上，Python对列表和其他序列的索引自然会导致从外到内的排序(第一个索引得到最大的分组，第二个索引得到最大的分组，最后一个索引得到最小的元素)。因为图像数据通常是按行存储的，所以这对应于行中最后一个索引项的位置。

如果您确实想使用Fortran排序，请认识到有两种方法需要考虑：1)接受第一个索引不是内存中变化最快的，并且在从内存到磁盘或从磁盘到VISA的过程中，让所有的I/O例程重新排序数据，或者使用numpy的机制将第一个索引映射到变化最快的数据。如果可能的话，我们推荐前者。后者的缺点是，除非小心使用‘Order’关键字，否则许多numpy函数将生成没有Fortran排序的数组。这样做会非常不方便。

否则，我们建议简单地学习在访问数组元素时颠倒索引的通常顺序。当然，这是违背原则的，但它更符合Python语义和数据的自然顺序。